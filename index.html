<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Software design principles for evolving architectures</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<style type="text/css"> 
			small {text-align: left;}
 			img { border:none;}
 			.pcenter {text-align:  center;}
 			.reveal section img {
 				border:none; 
 				box-shadow: none; 
 				background: #222222; 
 			};
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides"> 
				<section data-background="black">
					<h2>Software design principles for evolving architectures</h2> 
					<p class="pcenter"><small>firat atagun</small> </p>
					
				</section>
				<section data-background="#013D64">
					<h3>How to navigate</h3>

					<ul>
						<li>Use arrow keys to browse the slides</li>
						<li>CTRL+SHIFT+F to search</li>
						<li>Press ESC to view all slides</li>
					</ul>
				</section>

				<section data-background="#013D64">
					<h3>Table of Contents</h3>
					<ol style="font-size: 24px; width: 300px;">
						<li><a href="#/4">General Principles</a></li>
						<li><a href="#/5">SOLID Principles</a></li>
						<li><a href="#/6">Testable code</a></li>
						<li><a href="#/7">Code Smells</a></li>
						<li><a href="#/8">Architecture</a></li>
						<li><a href="#/9">Architectural Patterns</a></li>
					</ul>
				</section>

				<section data-background="#013D64">
					<p>This is not yet another monolith to microservices presentation.</p>
					<img src="images/monolith.png" />
				</section>

				<section data-background="#196F3D">
					
					<section>
						<h3>General Principles</h3>
					</section>

					<section>
						<h5>Dry</h5>
						<p>Every knowledge in a system must have a single authoritative, unambiguous representation. – Pragmatic Programmers.</p>
					</section>

					<section>
						<h5>YAGNI</h5>
						<p>Embrace principle of last responsible moment. <br/>
						   Postpone decisions until you can’t postpone them any further.<br/> 
						</p>
					</section>

					<section>
						<h5>KISS</h5>
						<p>
							Simple keeps focus.<br/>
							Good software design hides inherent complexity and avoids accidental complexity.
						</p>
					</section>

					<section>
						<h5>Principle of Cohesion</h5>
						<p>
							Removing and reducing coupling creates better design. <br/>
							What you need is high cohesion and loose coupling. 
						</p>
					</section>

					<section>
						<h5>Avoid Long Methods</h5>
						<p>
							Long methods are :
						</p>

						<ul>
							<li>Hard to test</li>
							<li>Hard to reason</li>
							<li>Hard to debug</li>
							<li>Hard to change</li>
							<li>Increases coupling and reduces cohesion</li>
						</ul>
					</section>

					<section>
						<h5>SLAP</h5>
						<p>
							Single level of abstraction principle with compose method pattern creates better design and increases usability.
						</p>
					</section>

					<section>
						<h5>Law of demeter</h5>
						<p>Principle of least knowledge aka Law of demeter tells that consumer of a method or a class shouldn't know or use the inner implementation details.</p>
					</section>

					<section>
						<h5>Principle of Least Surprise/Ashonisment</h5>
						<p>Code should work correctly or incorrectly in deterministic ways. Do not surprise consumers of your API.</p>
						<p>If a software has high astonishment factor, redesign it.</p>
					</section>

				</section>				

				<section data-background="#707B7C">
					<section>
						<h3>SOLID Principles</h3>
					</section>

					<section>
						<h4>SRP : Single Responsibility Principle</h4>
						<p>A class or a method should have only one reason to change.</p>
					</section>
						
					<section>
						<h5>OCP : Open Closed Principle</h5>
						<p>A class should be open for extension and closed for modification. </p>
					</section>

					<section>
						<h5>LSP : Liskov Substitution Principle</h5>
						<p>Classes that implements the same interface or class can be substituted.</p>
					</section>

					<section>
						<h5>ISP : Interface Segregation Principle</h5>
						<p>Interfaces should be specialized but not too special. </p>
					</section>

					<section>
						<h5>DI : Dependency inversion Principle</h5>
						<p>Depend on abstractions not on implementations. <br/>
							<a href="https://stackoverflow.com/questions/1638919/how-to-explain-dependency-injection-to-a-5-year-old" target="_new">How to explain dependency injection to 5 yearsold</a>
						</p>
						<p>Ask for things, do not look for things.</p>
					</section>
				</section>

				<section data-background="#34495E">
					<section>
						<h3>Testable code</h3>
					</section>

					<section> 
						<p>Code that can be tested in isolation, verifiable, deterministic and proved to be working properly at all times.</p>
						<p>Testable code increases cohesion and loose coupling while making software maintenance easier.</p>
					</section>

					<section>
						<h5>Why should we invest in developing testable code and tests?</h5>
					</section>

					<section>
						<p>Testable code and associated tests reduces bugs in development and maintenance</p>
					</section>

					<section>
						<p>Testing helps reduce effort and time of developing and maintaining our software.</p>
						<p>Fact: mainintaining software takes much more time and effort than developing it.</p>
						<p>Even though there is time and effort cost associated to creating tests, they pay of in the long time and increase trust to the software.</p>
					</section>

					<section> 
						<p>Testing our code helps improve the design of our software.</p>
					</section>

					<section>
						<p>Testing can help educate developers. It can be considered as documentation.</p>
						<p>If a developer wants to learn about a software, reading tests can help as much as reading documentation.</p>

					</section>

					<section>
						<p>Tests increases the trust and confidence in our software. </p> 
					</section>

					<section>
						<h5>Types of tests</h5>
					</section>

					<section>
						<h5>What</h5>
						<ul>
							<li>unit</li>
							<li>integration</li>
							<li>component</li>
							<li>service</li>
						</ul>
					</section>

					<section>
						<h5>Why</h5>
						<ul>
							<li>functional</li>
							<li>acceptance</li>
							<li>smoke</li>
						</ul>
					</section>

					<section>
						<h5>How</h5>
						<ul>
							<li>automated</li>
							<li>manual</li>
						</ul>
					</section>

					<section>
						<h5>Seams</h5>
						<p>Building blocks of software in isolation. Can be thought of context or bounded context</p>
					</section>

					<section>
						<h5>Object construction</h5>
						<p>Constructors shouldn't contain any logic. Constructors should be as simple as possible. </p>
						<p>There are injectables and newables. Injectables are like services that implements an interface. Newables usually represents entity. Injectables can accept other injectables but shouldn't accept newables. Newables can accept other newables but shouldn't accept any injectables.</p>
					</section>

					<section>
						<h5>Use polymorphism over conditionals</h5>
						<p>if you see a repeating pattern of same conditionals you can extract it into polymorphic constructs. Break complex classes to smaller simpler classes.</p>
					</section>

					<section>
						<h5>Law of demeter</h5>
						<p>Talk to your friends. Don't talk to strangers.</p>
						<pre><code class="hljs">var customer = _customerService.GetCustomer(id);
var userName = Environment.GetSecurity().GetLogin.GetUser().UserName;</code></pre>
						<p>Except Builder pattern this is a bad practice because it violates the law of demeter and makes testing harder.</p>
					</section>
				</section>

				<section data-background="#E74C3C">
					<section>
						<h3>Code Smells</h3>
					</section>
					<section>
						<h5>Rigidity</h5>
						<p>If there is tension for the software to change, then your software is suffering from rigidity.</p>
						<p>Rigidity arises from coupling objects and components in such a way that making a change becomes tedious.</p>
						<p>Rigidity causes fragility</p>
					</section>

					<section>
						<h5>Fragility</h5>
						<p>If your breaks easily, causes failures, that is a sign of fragility.</p>
						<p>It is very easy to detect a fragile code such as a small change in your software breaks many other dependencies.</p>
					</section>

					<section>
						<h5>Immobility</h5>
						<p>If your code is hard to reuse, that is immobility. </p>
						<p>Use interfaces more. Balance generic classes. Create re-usable components.</p>
					</section> 

					<section>
						<h5>Viscocity</h5>
						<p>If your software is easy to hack but hard to fix properly, that is a bad sign.</p>
						<p>Maintaining principles and practices is challenging, therefore sometimes developers hack their way through.</p>
					</section> 

					<section>
						<h5>Complexity</h5>
						<p>
							Software engineers love complicated stuff, they enjoy it.
						</p>
						<p>
							However, Everything that is too complicated is destined to fail. If something feels complicated it is most probably wrong.
						</p> 
					</section>

					<section>
						<h5>Duplication</h5>
						<p>
							Code duplication is a typical symptom of a bad design. 
						</p>
						<p>
							Duplication of code causes a bug to show up in multiple places, thus requires duplication of effort as well.  
						</p>
					</section>

					<section>
						<h5>Opacity</h5>
						<p>If your software is hard to understand, that is a bad sign.</p>

						<p>Your software should be clear, concise, easy and should read like a poem.</p>
					</section>
				</section>

				<section data-background="#AF7AC5">
					<section>
						<h3>Architecture</h3>
					</section>

					<section>
						<p>Architecture is set of design decisions and shared understanding of a system.</p>
					</section>

					<section>
						<h5>Big up front design</h5>
						<p>Architectural decisions should be balanced. Big up front design is generally a bad practice. Just enough design is usually good enough. "Just enough" is based on your intuition. </p>
					</section>

					<section>
						<img src="images/understanding.png" style="height: 400px;" />
						<p>Prioratize Features based on Value and architectural impacts.</p>
					</section>

					<section>
						<h5>Design stamina hypothesis</h5>
						<img src="images/designstamina.png" style="height: 400px;" />
					</section>

					<section>
						<h5>Reversibility</h5>
						<p>An architectural decisions should be reversible.</p>
					</section>
				</section>

				<section>
					<section>
						<h3>Architectural Patterns</h3>
					</section>

					<section>
						<h3>Source code</h3>
						<p><a href="https://github.com/fatagun/SoftwareArchitectures" target="target">Software Architectures</a></p>
					</section>

					<section>
						<h5>Layered Architecture</h5>
						<img src="images/layered.png" />
					</section>

					<section>
						<h5>Layered Architecture</h5>
						<img src="images/standardmvc.png" />
					</section> 

					<section>
						<h5>Feature Based Slicing</h5>
						<img src="images/features.png" />
					</section>

					<section>
						<h5>Feature Based Slicing</h5>
						<img src="images/slices.png" />
					</section>

					<section>
						<h5>Kernel/Plugin Architecture</h5>
						<img src="images/kernel.png" />
					</section>

					<section>
						<h5>Event Driven Architecture</h5>
						<p>Mediator</p>
						<img src="images/mediator.png" />
						<p>Event Managers</p>
					</section>

					<section>
						<h5>CQRS</h5>
						<p>Command Query Responsibility Segregation</p>
						<img src="images/cqrs.png" style="height: 350px;" />
					</section>

					<section>
						<h5>MicroServices</h5>
						<img src="images/microservices.png" />
					</section>

					<section>
						<h5>Architecture Comparison</h5>
						<img src="images/comparison.png" />
					</section>


				</section>
 
				<section data-background="#2E86C1">
					<h3>The end.</h3>	

				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/search/search.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
 
		</script>
	</body>
</html>
